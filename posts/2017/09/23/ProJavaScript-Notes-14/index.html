<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>重读 JS 高程（Chapter20、Chapter21） | cz&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Chapter20. JSONJSON 是一种数据格式，不是一种编程语言。虽然具有相同的语法形式，但 JSON 并不从属于 JavaScript。 语法JSON 的语法可以表示一下三种类型的值。  简单值：使用与 JavaScript 相同的语法，可以在 JSON 表示字符串、数值、布尔值和null。但 JSON 不支持 JavaScript 中的特殊值undefined。 对象：对象作为一种复杂">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="重读 JS 高程（Chapter20、Chapter21）">
<meta property="og:url" content="http://yoursite.com/posts/2017/09/23/ProJavaScript-Notes-14/index.html">
<meta property="og:site_name" content="cz&#39;s blog">
<meta property="og:description" content="Chapter20. JSONJSON 是一种数据格式，不是一种编程语言。虽然具有相同的语法形式，但 JSON 并不从属于 JavaScript。 语法JSON 的语法可以表示一下三种类型的值。  简单值：使用与 JavaScript 相同的语法，可以在 JSON 表示字符串、数值、布尔值和null。但 JSON 不支持 JavaScript 中的特殊值undefined。 对象：对象作为一种复杂">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-09-23T16:42:24.945Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="重读 JS 高程（Chapter20、Chapter21）">
<meta name="twitter:description" content="Chapter20. JSONJSON 是一种数据格式，不是一种编程语言。虽然具有相同的语法形式，但 JSON 并不从属于 JavaScript。 语法JSON 的语法可以表示一下三种类型的值。  简单值：使用与 JavaScript 相同的语法，可以在 JSON 表示字符串、数值、布尔值和null。但 JSON 不支持 JavaScript 中的特殊值undefined。 对象：对象作为一种复杂">
  
    <link rel="alternative" href="/atom.xml" title="cz&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-ProJavaScript-Notes-14" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      重读 JS 高程（Chapter20、Chapter21）
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/posts/2017/09/23/ProJavaScript-Notes-14/" class="article-date">
  <time datetime="2017-09-22T17:03:30.000Z" itemprop="datePublished">2017-09-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Chapter20-JSON"><a href="#Chapter20-JSON" class="headerlink" title="Chapter20. JSON"></a>Chapter20. JSON</h2><p>JSON 是一种数据格式，不是一种编程语言。虽然具有相同的语法形式，但 JSON 并不从属于 JavaScript。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JSON 的语法可以表示一下三种类型的值。</p>
<ul>
<li>简单值：使用与 JavaScript 相同的语法，可以在 JSON 表示字符串、数值、布尔值和<code>null</code>。但 JSON 不支持 JavaScript 中的特殊值<code>undefined</code>。</li>
<li>对象：对象作为一种复杂的数据类型，表示的是一组无序的键值对。每个键值对中的值可以是简单值，也可以是复杂的数据类型的值。</li>
<li>数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型。</li>
</ul>
<p>JSON 不支持变量、函数或者对象实例，它就是一种表示结构化数据的格式。</p>
<h4 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h4><blockquote>
<p>最简单的 JSON 数据形式就是简单值。</p>
</blockquote>
<p>值得注意的是，JSON 字符串必须使用双引号，其他和 JavaScript 没有区别。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>JSON 中的对象要求给属性加双引号，属性的值可以是复杂类型。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Nicholas&quot;,</span><br><span class="line">    &quot;age&quot;: 29,</span><br><span class="line">    &quot;school&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Merrimack College&quot;,</span><br><span class="line">        &quot;location&quot;: &quot;North Andover, MA&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>JSON 的数组可以与对象结合起来，构成复杂的数据结构。</p>
<a id="more"></a>
<h3 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h3><p>JSON 的流行是因为可以把它直接转换成 JavaScript 对象，比用 DOM 方法解析 XML 要容易许多。</p>
<h4 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h4><p>早期的 JSON 解析器基本上就是用 JavaScript 的<code>eval()</code>函数。由于 JSON 是 JavaScript 语法的子集，因此<code>eval()</code>函数可以解析、解释并返回 <code>JavaScript</code>对象和数组。</p>
<p>ES5 对解析 JSON 的行为进行了规范，定义了全局对象 JSON。该对象有两个方法：<code>stringify()</code>和<code>parse()</code>。最简单的情况下，这两个方法分别用于把 JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。</p>
<p>序列化 JavaScript 对象时，所有函数及原型成员都会被有意忽略，不会体现在结果，另外值为 undefined 的任何属性也都会被跳过。最终值都是有效的 JSON 数据类型。</p>
<h4 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h4><p><code>JSON.stringify()</code>除了要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化 JavaScript 对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数；第二个参数是一个选项，表示是否在 JSON 字符串中保留缩进。</p>
<p><strong>过滤结果</strong></p>
<p>如果过滤器参数是数组，那么<code>JSON.stringify()</code>的结果将只包含数组中列出的属性。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    authors: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">"title"</span>, <span class="string">"edition"</span>]);</span><br><span class="line">alert(jsonText); <span class="comment">// &#123;"title":"Professional JavaScript","edition":3&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果第二个参数是一个函数，传入的函数接收两个参数，属性名和属性值。根据属性名可以知道应该如何处理要序列化的对象中的属性，函数的返回值就是相应属性的值。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    authors: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"authors"</span>:</span><br><span class="line">            <span class="keyword">return</span> value.join(<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"year"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"edition"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>字符串缩进</strong></p>
<p><code>JSON.stringify()</code>方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数。要在每个级别缩进 4 个空格，可以这样设置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    authors: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>最大缩进空格数为 10，所有大于 10 的值都会自动转换为 10。</p>
<p>如果缩进参数是一个字符串而不是数值，则这个字符串将在 JSON 字符串中被用作缩进字符。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">   <span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="string">"--"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>toJSON() 方法</strong></p>
<p>有些情况下，可以给对象定义<code>toJSON()</code>方法，返回其自身的 JSON 数据格式。原生 Date 对象有一个<code>toJSON()</code>方法，能够将 JavaScript 的 Date 对象自动转换成 ISO 8601 日期字符串。可以为任何对象添加<code>toJSON()</code>方法，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">   <span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span>,</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br></pre></td></tr></table></figure>
<p>用<code>JSON.stringify()</code>序列化对象的顺序：</p>
<ul>
<li>如果存在<code>toJSON()</code>方法而且能够通过它取得有效值，则调用该方法，否则返回对象本身。</li>
<li>如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是上一步返回的值。</li>
<li>进行序列化。</li>
<li>有第三个参数，执行格式化。</li>
</ul>
<h4 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h4><p><code>JSON.parse()</code>方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。这个函数与<code>JSON.stringify()</code>的第二参数类似，不过被被称为还原函数。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">   <span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span>,</span><br><span class="line">    releaseDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">"releaseDate"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"releaseDate"</span> <span class="keyword">in</span> bookCopy); <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure>
<h2 id="Chapter21-Ajax-与-Comet"><a href="#Chapter21-Ajax-与-Comet" class="headerlink" title="Chapter21. Ajax 与 Comet"></a>Chapter21. Ajax 与 Comet</h2><p>Ajax 是 Asynchronous JavaScript and XML 的缩写，在 2005 年被发现后，成为了沿用至今的浏览器端与服务器端的交互方式。</p>
<h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>, <span class="string">"MSXML2.XMLHttp"</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">                    <span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">                    <span class="comment">//skip</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>
<h4 id="XHR-的用法"><a href="#XHR-的用法" class="headerlink" title="XHR 的用法"></a>XHR 的用法</h4><p>使用 XHR 对象时，要调用的第一个方法是<code>open()</code>，它接受 3 个参数：要发送的请求类型（”get”、”post”等）、请求的 URL 和表示是否异步发送请求的布尔值。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"exeample.php"</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>URL 是相对于执行代码的当前页面（当然也可以使用绝对路径）</li>
<li><code>open()</code>方法并不会真正发送请求，而只是启动一个请求以备发送。</li>
</ul>
<p>要发送请求，必须调用<code>send()</code>方法，接受一个参数，即要作为请求主体发送的数据。如果不需要发送数据，则传入<code>null</code>。调用<code>send()</code>之后，请求就会被分派到服务器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>这次请求是同步请求，JavaScript 代码会等到服务器响应后再继续执行。收到服务器响应后，相应的数据会自动填充 XHR 对象的属性，相关属性如下：</p>
<ul>
<li><code>responseText</code>：作为响应主体被返回的文本。</li>
<li><code>responseXML</code>：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的 XML DOM 文档。</li>
<li><code>status</code>：响应的 HTTP 状态。</li>
<li><code>statusText</code>：HTTP 的说明。</li>
</ul>
<p>接收到响应，第一步是检查<code>status</code>属性，一般来说 HTTP 状态代码为 200 时响应成功，304 表示资源未修改，可以直接使用缓存，也意味着响应有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为确保接收到适当的响应 200:成功，304:资源未被修改</span></span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>有的浏览器会错误的报告成功状态码为 204 </li>
<li>无论内容类型是什么，响应主体的内容都会保存到<code>responseText</code>属性中；而对于 XML 数据而言，<code>responseXML</code>同时也将被赋值，否则其值为<code>null</code>。</li>
</ul>
<p>对于异步请求，可以检测 XHR 对象的<code>readyState</code>属性，该属性表示请求/响应过程的当前活动阶段：</p>
<ul>
<li>0：未初始化。尚未调用<code>open()</code>方法。</li>
<li>1：启动。已经调用<code>open()</code>方法，但尚未调用<code>send()</code>方法。</li>
<li>2：发送。已经调用<code>send()</code>方法，但尚未接收到响应。</li>
<li>3：接收。已经接收到部分响应数据。</li>
<li>4：完成。已经接收全部响应数据，而且已经可以在客户端使用了。</li>
</ul>
<p><code>readyState</code>值发生变化，会触发<code>readystatechange</code>事件。可以利用这个事件来检测每次状态变化后<code>readyState</code>的值。不过，必须在调用<code>open()</code>之前指定<code>onreadystatechange</code>事件处理程序才能确保跨浏览器兼容性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();        </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>在接收到响应数据之前可以调用<code>abort()</code>方法来取消异步请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.abort();</span><br><span class="line">xhr = <span class="literal">null</span>; <span class="comment">// 解除引用，释放内存</span></span><br></pre></td></tr></table></figure>
<h4 id="HTTP-头部信息"><a href="#HTTP-头部信息" class="headerlink" title="HTTP 头部信息"></a>HTTP 头部信息</h4><p>默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。</p>
<ul>
<li>Accept：浏览器能处理的内容类型。</li>
<li>Accept-Charset：浏览器能显示的字符集。</li>
<li>Accept-Encoding：浏览器能处理的压缩编码。</li>
<li>Accept-Language：浏览器当前设置的语言。</li>
<li>Connection：浏览器与服务器之间连接的类型。</li>
<li>Cookie：当前页面设置的任何 Cookie。</li>
<li>Host：发送请求的页面所在的域。</li>
<li>Referer：发出请求的页面的 URL。</li>
<li>User-Agent：浏览器的用户代理字符串。</li>
</ul>
<p>使用<code>setRequestHeader()</code>可以设置自定义的请求头信息。这个方法接受两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用<code>open()</code>方法之后且调用<code>send()</code>方法之前调用<code>setRequestHeader()</code>。 </p>
<p>调用<code>getResponseHeader()</code> 方法并传入头部字段名称，可以取得相应的响应头部信息。而调用<code>getAllResponseHeaders()</code>可以取得一个包含所有头部信息的长字符串。</p>
<h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><p>GET 是最常见的请求类型，最常用语向服务器查询某些信息。必要时可以将查询字符串添加到 URL 末尾，以便将信息发送给服务器。对于 XHR 而言，位于传入<code>open()</code>方法的 URL 末尾查询字符串必须经过正确的编码才行。查询字符串的每个参数的名称和值都必须使用<code>encodeURIComponent()</code>进行编码。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, name, value</span>) </span>&#123;</span><br><span class="line">    url += (url.indexOf(<span class="string">"?"</span>) == <span class="number">-1</span> ? <span class="string">"?"</span> : <span class="string">"&amp;"</span>);</span><br><span class="line">    url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"http://test.com"</span>;</span><br><span class="line">url = addURLParam(url, <span class="string">"uid"</span> , <span class="number">5</span>);</span><br><span class="line">url = addURLParam(url, <span class="string">"siteid"</span>, <span class="number">123</span>);  <span class="comment">// "http://test.com?uid=5&amp;siteid=123"</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h4><p>POST 请求通常用于向服务器发送应该被保存的数据，POST 请求应该把数据作为请求的主体提交。模拟表单提交时，需要要 Content-Type 头部信息设置为 application/x-www-form-urlencoded。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 发送请求 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">                alert(xhr.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.open(<span class="string">"post"</span>, <span class="string">"postexample.php"</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 表单提交的内容类型</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"user-info"</span>);</span><br><span class="line">    <span class="comment">// 请求主体为数据</span></span><br><span class="line">    xhr.send(serialize(form));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h3><p>XMLHttpRequest 1 级只是把已有的 XHR 对象的实现细节描述了出来，而 XMLHttpRequest 2 级则进一步发展了 XHR。</p>
<h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>FormData 为序列化表单以及创建与表单格式相同的数据提供便利。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br></pre></td></tr></table></figure>
<p><code>append()</code>方法接受两个参数：键和值，分别对应表单字段的名字和字段中包含的值。</p>
<p>创建了 FormData 的实例后，可以将它直接传给 XHR 的<code>send()</code>方法。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"example.php"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"user-info"</span>);</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(form));</span><br></pre></td></tr></table></figure>
<p>使用 FormData 的方便之处在于不必明确地在 XHR 对象上设置请求头。</p>
<h4 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h4><p>IE8 为 XHR 对象添加了一个<code>timeout</code>属性，表示请求在等待响应多少毫秒后就终止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"timeout.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.timeout = <span class="number">1000</span>;</span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Request did not return in a second."</span>);</span><br><span class="line">&#125;;        </span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>对于其他浏览器的兼容做法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"timeout.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    xhr.abort();</span><br><span class="line">    xhr = <span class="literal">null</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="overrideMimeType-方法"><a href="#overrideMimeType-方法" class="headerlink" title="overrideMimeType() 方法"></a>overrideMimeType() 方法</h4><p>该方法用于重写 XHR 响应的 MIME 类型。如果服务器返回的 MIME 类型是 text/plain，但数据中实际包含的是 XML。根据 MIME 类型，responseXML 属性中仍然是<code>null</code>。此时，通过<code>overrideMimeType()</code>方法，可以保证把响应当作 XML 而非纯文本来处理。调用该方法必须在<code>send()</code>方法之前。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"text.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.overrideMimeType(<span class="string">"text/xml"</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><ul>
<li>loadstart：在接收到响应数据的第一个字节时触发。</li>
<li>progress：在接收响应期间持续不断地触发。</li>
<li>error：在请求发生错误时触发。</li>
<li>abort：在因为调用abort()方法而终止时触发。</li>
<li>load：在接收到完整的响应数据时触发。</li>
<li>loadend：在通信完成或者触发error、abort或load事件后触发。 </li>
</ul>
<h4 id="load-事件"><a href="#load-事件" class="headerlink" title="load 事件"></a>load 事件</h4><p>可以代替<code>readystatechange</code>事件。其处理程序会接收到一个<code>event</code>对象，其<code>target</code>属性指向 XHR 对象实例，因而可以访问到 XHR 对象的所有方法和属性。然而，并非所有浏览器都实现了事件对象。</p>
<h4 id="progress-事件"><a href="#progress-事件" class="headerlink" title="progress 事件"></a>progress 事件</h4><p>事件处理程序会接收一个<code>event</code>对象，其<code>target</code>属性指向 XHR 对象实例，而且包含 3 个额外属性：</p>
<ul>
<li><code>lengthComputable</code>：是一个表示进度信息是否可用的布尔值。</li>
<li><code>position</code>：表示已经接收的字节数。</li>
<li><code>totalSize</code>：根据 Content-Length 响应头部而确定的预期字节数 。</li>
</ul>
<p>必须在调用<code>open()</code>方法之前添加<code>onprogress</code>事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();        </span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">"status"</span>);</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable)&#123;</span><br><span class="line">        divStatus.innerHTML = <span class="string">"Received "</span> + event.position + <span class="string">" of "</span> + event.totalSize + <span class="string">" bytes"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"altevents.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="跨源资源共享"><a href="#跨源资源共享" class="headerlink" title="跨源资源共享"></a>跨源资源共享</h3><p>CORS（Cross-Origin Resource Sharing）背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
<p>在发送请求时，给其附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nozonline.net</span><br></pre></td></tr></table></figure>
<p>如果服务器认为这个请求可以接受，在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发”**”）。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nozonline.net</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：请求和响应都不包含 cookie 信息。</p>
<h4 id="IE-对-CORS-的实现"><a href="#IE-对-CORS-的实现" class="headerlink" title="IE 对 CORS 的实现"></a>IE 对 CORS 的实现</h4><p>IE8 中引入 XDR（XDomainRequest）类型，用来实现安全可靠的跨域通信。与 XHR 不同之处：</p>
<ul>
<li>cookie 不会随请求发送，也不会随响应返回。</li>
<li>只能设置请求头部信息中的 Content-Type 字段。</li>
<li>不能访问响应头部信息</li>
<li>只支持 GET 和 POST 请求</li>
</ul>
<p>XDR 使用方法类似于 XHR，不过所有的 XDR 请求都是异步的，不能创建同步请求。XDR 提供<code>contentType</code> ，这个属性是通过 XDR 对象影响头部信息的唯一方式。</p>
<h4 id="其他浏览器对CORS的实现"><a href="#其他浏览器对CORS的实现" class="headerlink" title="其他浏览器对CORS的实现"></a>其他浏览器对CORS的实现</h4><p>通过 XMLHttpRequest 对象实现对 CORS 的原生支持，只需给<code>open()</code>方法传入<strong>绝对 URL</strong> 即可，支持同步请求。跨域XHR对象的安全限制： </p>
<ul>
<li>不能使用<code>setRequestHeader()</code>设置自定义头部。 </li>
<li>不能发送和接收 cookie。 </li>
<li>调用<code>getAllResponseHeaders()</code>方法总会返回空字符串。</li>
</ul>
<p><strong>建议</strong>：访问本地资源，最好使用相对URL；访问远程资源，使用绝对URL。</p>
<h4 id="Preflighted-Requests"><a href="#Preflighted-Requests" class="headerlink" title="Preflighted Requests"></a>Preflighted Requests</h4><p>CORS 通过一种叫做 Preflighted Requests 的透明服务器验证机制支持开发人员使用自定义头部、GET 或 POST 之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会向服务器发送一个 Prefilght 请求。这种请求使用 OPTIONS 方法，发送以下头部。</p>
<ul>
<li>Origin：与简单的请求相同。</li>
<li>Access-Control-Request-Method：请求自身使用方法。</li>
<li>Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。</li>
</ul>
<p>以下是一个带有自定义头部 NCZ 的使用 POST 方法发送的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br></pre></td></tr></table></figure>
<p>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。</p>
<ul>
<li>Access-Control-Allow-Origin：与简单的请求相同。</li>
<li>Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔。</li>
<li>Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔。</li>
<li>Access-Control-Allow-Max-Age：应该将这个 Preflight 请求缓存多长时间（以秒表示）。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.ncznoline.net</span><br><span class="line">Access-Control-Allow-Methods: POST, GET</span><br><span class="line">Access-Control-Allow-Headers: NCZ</span><br><span class="line">Access-Control-Allow-Max-Age: 1728000</span><br></pre></td></tr></table></figure>
<p>IE 11+ 支持</p>
<h4 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h4><p>默认情况下，跨域请求不提供凭据（cookie、HTTP认证及客户端 SSL 证明等）。通过将<code>withCrentials</code>属性设置为<code>true</code>，可以指定某个请求应该发送凭据。如果服务器接收带凭据的请求，会用下面的 HTTP 头部来响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript。另外，服务器还可以在 Preflight 响应中发送这个 HTTP 头部，表示允许源发送带凭据的请求。</p>
<h4 id="跨浏览器的CORS"><a href="#跨浏览器的CORS" class="headerlink" title="跨浏览器的CORS"></a>跨浏览器的CORS</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method, url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr)&#123; <span class="comment">// 检测 XHR 是否支持 CORS 的简单方式，就是检测是否存在 withCredentials 属性</span></span><br><span class="line">        xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XDomainRequest != <span class="string">"undefined"</span>)&#123;    <span class="comment">// IE XDR</span></span><br><span class="line">        xhr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = createCORSRequest(<span class="string">"get"</span>, <span class="string">"http://www.somewhere-else.com/page/"</span>);</span><br><span class="line"><span class="keyword">if</span> (request)&#123;</span><br><span class="line">    request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do something with request.responseText</span></span><br><span class="line">    &#125;;</span><br><span class="line">    request.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h3><p>利用 DOM 中能够执行跨域请求的功能，在不依赖 XHR 对象的情况下也能发送某种请求，不需要修改服务器端代码。</p>
<h4 id="图像Ping"><a href="#图像Ping" class="headerlink" title="图像Ping"></a>图像Ping</h4><p><code>&lt;img&gt;</code>标签，可以从任何网页中加载图像，无需关注是否跨域。这也是广告跟踪浏览量的主要方式。可以通过动态创建图像，使用<code>onload</code>和<code>onerror</code>事件处理程序缺人是否接受到了响应 。</p>
<p>动态创建图像经常用于图像 Ping。图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串的形式发送的，响应可以是任意内容，但通常是像素图或 204 响应。浏览器得不到任何具体的数据，但通过监听 load 和 error 事件，可以知道响应是什么时间接收到的。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.error = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="string">"http://www.test.com/getImage?id=1"</span>;</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>只能发送 GET 请求</li>
</ul>
<ul>
<li>无法访问服务器的响应文本</li>
</ul>
<h4 id="JSONP（JSON-with-padding）"><a href="#JSONP（JSON-with-padding）" class="headerlink" title="JSONP（JSON with padding）"></a>JSONP（JSON with padding）</h4><p>JSONP 由两部分组成：回调函数和数据。 回调函数是当响应到来时应该在页面调用的函数。回到函数的名字一般是在请求中指定的。而数据是传入回调函数中的 JSON 数据。 JSONP 是通过动态<code>&lt;script&gt;</code>元素来使用的，使用时可以为<code>src</code>属性指定一个跨域 URL。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"You're at IP address "</span> + response.ip + <span class="string">", which is in "</span> + response.city + <span class="string">", "</span> + response.region_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.src = <span class="string">"http://freegeoip.net/json/?callback=handleResponse"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure>
<p>优点：能够直接访问响应文本，支持在浏览器与服务器之间双向通信。 </p>
<p>缺点： </p>
<ul>
<li>JSONP 是从其他域中加载代码执行，其安全性无法确保。 </li>
<li>不能很容易的确定 JSONP 请求是否失败。</li>
</ul>
<h4 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h4><p>Comet 是一种更高级的 Ajax 技术，是一种服务器向页面推送数据的技术。 有两种实现 Comet 的方式：长轮询和流。 </p>
<ul>
<li>长轮询：页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。轮询的优势是所有浏览器都支持。</li>
<li>HTTP 流：流不同于轮询，它在页面的生命周期内只使用一个 HTTP 连接。具体来说就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。所有服务器端语言都支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客服端）的功能，这正是实现 HTTP 流的关键所在。通过检测<code>readyState</code>是否为 3，就可以利用 XHR 对象实现 HTTP 流。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStreamingClient</span>(<span class="params">url, progress, finished</span>)</span>&#123;        </span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(),</span><br><span class="line">        received = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    xhr.open(<span class="string">"get"</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">//get only the new data and adjust counter</span></span><br><span class="line">            result = xhr.responseText.substring(received);</span><br><span class="line">            received += result.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//call the progress callback</span></span><br><span class="line">            progress(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">            finished(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = createStreamingClient(<span class="string">"streaming.php"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Received: "</span> + data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h4><p>SSE（Sever-Sent Events，服务器发送事件） 是围绕只读 Comet 交互推出的 API 或者模式。SSE  API 用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME 类型必须是 text/event-stream，而且是浏览器中的 JavaScript API 能解析格式输出。SSE 支持轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。</p>
<p><strong>SSE API</strong></p>
<p>要预订新的事件流，首先要创建一个新的 EventSource 对象，并传进一个入口点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">"myevents.php"</span>);</span><br></pre></td></tr></table></figure>
<p>传入的 URL 必须与创建对象的页面同源。EventSource 的实例有一个<code>readyState</code>属性，值为 0 表示正在连接到服务器，值为 1 表示打开了连接，值为 2 表示关闭了连接。另外，还有以下三个事件：</p>
<ul>
<li>open：在建立连接时触发。</li>
<li>message：在从服务器接收到新事件时触发。</li>
<li>error：在无法建立连接时触发。</li>
</ul>
<p>服务器发回的数据以字符串形式保存在<code>event.data</code>中，默认情况下 EventSource 对象会保持与服务器的活动连接。如果连接断开还会重新连接。想强制立即断开连接并不再重新连接，可以调用<code>close()</code>方法。</p>
<p><strong>事件流</strong></p>
<p>所谓的服务器事件会通过一个持久的 HTTP 响应发送，这个响应的 MIME 类型为 text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀的<code>data:</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: foo</span><br><span class="line"></span><br><span class="line">data: bar</span><br><span class="line"></span><br><span class="line">data: foo</span><br><span class="line">data: bar</span><br></pre></td></tr></table></figure>
<p>每个值之间以一个换行符分隔，只有在包含<code>data:</code>的数据行后面有空行时，才会触发 message 事件。</p>
<p>通过<code>id:</code>前缀可以给特定事件指定一个关联的 ID ，这个 ID 行位于<code>data:</code>行前面或后面均可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data: foo</span><br><span class="line">id: 1</span><br></pre></td></tr></table></figure>
<p>设置了 ID 以后，EventSource 对象会跟踪上一次触发的事件。如果断开连接，会向服务器发送一个包含名为 Last-Event-ID 的特殊 HTTP 头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。</p>
<h4 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h4><p>Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。 在 JavaScript 创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会从 HTTP 协议变为 Web Socket 协议。</p>
<p>由于 Web Sockets 使用了自定义协议，所以 URL 模式也略有不同。未加密的连接不再是 http://，而是 ws://；加密的连接也不是 https://，而是 wss://。</p>
<p>使用自定义协议而非 HTTP 协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心 HTTP 那样字节级的开销。由于传递的数据包很小，因此 Web Sockets 非常适合移动应用。</p>
<p><strong>Web Sockets API</strong></p>
<p>要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br></pre></td></tr></table></figure>
<p>必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接。</p>
<p>WebSocket 也有一个表示当前状态的<code>readystate</code>属性。不过这个属性的值与 XHR 并不相同：</p>
<ul>
<li>WebSocket.OPENING(0)：正在建立连接</li>
<li>WebSocket.OPEN(1)：已经建立连接</li>
<li>WebSocket.CLOSING(2)：正在关闭连接</li>
<li>WebSocket.CLOSE(3)：已经关闭连接</li>
</ul>
<p>要关闭 Web Socket 连接，可以调用<code>close()</code>方法。</p>
<p><strong>发送和接收数据</strong></p>
<ul>
<li><code>send()</code>：可以向服务器发送数据。接受一个参数，任意字符串。复杂数据可以先用<code>JSON.stringify()</code>序列化字符串再发送。</li>
<li>当服务器向客户端发来消息时，WebSocket 对象会触发 messge 事件。这个事件与其他传递消息的协议类似，也是把返回的数据保存在<code>event.data</code>属性中。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须给WebSocket构造函数传入绝对URL</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br><span class="line"><span class="comment">// 向服务器发送数据（只能发送纯文本，其他数据需要序列化）</span></span><br><span class="line">socket.send(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 接收服务器的响应数据</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>其他事件</strong></p>
<p>WebSocket 对象还有其他三个事件，在连接生命周期的不同阶段触发。</p>
<ul>
<li>open：在成功建立连接时触发。</li>
<li>error：在发生错误时触发，连接不能持续。</li>
<li>close：在连接关闭时触发。</li>
</ul>
<p>WebSocket 对象不支持 DOM 2 级事件侦听器。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br><span class="line"></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Connection established"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Connection error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Connection closed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这三个事件中，只有 close 事件的<code>event</code>对象有额外的信息。这个事件的事件对象有 3 个额外的属性：</p>
<ul>
<li>wasClean：是一个布尔值，表示连接是否已经明确地关闭；</li>
<li>code：服务器返回的数值状态码；</li>
<li>reason：是一个字符串，包含服务器发回的消息。</li>
</ul>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/posts/2017/09/24/ProJavaScript-Notes-15/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          重读 JS 高程（Chapter22）
        
      </div>
    </a>
  
  
    <a href="/posts/2017/09/22/ProJavaScript-Notes-13/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">重读 JS 高程（Chapter16-Chapter19）</div>
    </a>
  
</nav>

  
</article>


</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/dtcz" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>

      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2018 cz 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/hejianxian/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/dtcz" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>